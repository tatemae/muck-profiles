= MuckProfiles

Add profiles to muck users.  This implements a photo for users as well as a property bag that enables total customization of the user's profile information including privacy settings.

== Installation
Muck profile relies upon the muck-engine and muck-users gems as well as paperclip.  Add the following lines to your environment.rb file:

  config.gem "authlogic"
  config.gem "searchlogic"
  config.gem "bcrypt-ruby", :lib => "bcrypt"
  config.gem 'paperclip'
  config.gem 'muck-engine', :lib => 'muck_engine'
  config.gem 'muck-users', :lib => 'muck_users'
  config.gem 'muck-profiles', :lib => 'muck_profiles'
  config.gem 'geokit'

Next run rake gems:install

MuckProfiles uses geokit to determine a users location and to make it possible to find users that are within a given proximity.

Install the GeoKit Rails Plugin:

  script/plugin install git://github.com/andre/geokit-rails.git

Be sure to get api keys from Google an Yahoo.  Instructions for doing so can be found in config/initializers/geokit_config.rb after installing the plugin.  We recommend moving the keys into
global_config.yml:

Change the lines in config/initializers/geokit_config.rb to:
  Geokit::Geocoders::yahoo = GlobalConfig.yahoo_geo_key
  Geokit::Geocoders::google = GlobalConfig.google_geo_key

Put this in global_config.yml:
  google_geo_key: 'some key'  # API key for Google.  Get it here: http://www.google.com/apis/maps/signup.html
  yahoo_geo_key: 'some key'   # API key for Yahoo.  Get it here: http://developer.yahoo.com/faq/index.html#appid

# Profile configuration
  enable_guess_location: true # If true the profile system will attempt to determine the user's location via IP and populated with the location, lat and lon fields.
  
== Usage
Create a model called profile.rb and add 'acts_as_muck_profile'.  This mixes in the muck profile functionality but also permits further customization of the profile in your application.

  class Profile < ActiveRecord::Base
    acts_as_muck_profile
  end

Modify your user model so that it has a profile:

  class User < ActiveRecord::Base
    acts_as_authentic do |c|
      c.crypto_provider = Authlogic::CryptoProviders::BCrypt
    end
    acts_as_muck_user
    has_muck_profile
  end


Your user model will now appear to have a 'photo' which is delegated to the profile model:

  @user.photo # returns a photo object from paperclip

=== Acts as Solr

Add the following to global_config.yml
  profile_enable_solr: true # This enables or disables acts as solr for profiles.
  
If you enable acts as solr you'll also want to specify a default policy.  This policy is used to determine which fields are public and private.
The default policy looks like this:

  :policy => { :public => [:login, :first_name, :last_name, :about],
               :authenticated => [:location, :city, :state_id, :country_id, :language_id],
               :friends => [:email],
               :private => [] }

If you add attributes to the profile as show below then you will want to specify which fields fall into each privacy setting.  Note that it is also
possible to add new privacy levels simply by adding new values to the hash.  For example:

  :policy => { :public => [:login, :first_name, :last_name, :about],
               :authenticated => [:location, :city, :state_id, :country_id, :language_id],
               :friends => [:email],
               :private => [],
               :instructors => [:grades] }

For each top level key a method will be auto generated that returns the values from each attribute concatenated together.
Assuming we have a profile with fields populated calling each method might return something like this:
  
  @profile.public_fields         # returns 'testguy test guy I am the test guy'
  @profile.authenticated_fields  # returns 'somewhere USA English'
  @profile.friends_fields        # returns 'test@example.com'
  @profile.private_fields        # returns ' '

Solr will index these fields and then permit you to search based on each privacy level.

=== Profile Attributes
The profile comes preconfigured with a basic set of common profile options.  It is easy to add new fields.  Simply add the fields to the profile using a migration:

  class AddMoreFieldsToProfiles < ActiveRecord::Migration
    def self.up
      add_column :profiles, :occupation, :string
      add_column :profiles, :gender, :string
      add_column :profiles, :birthday, :datetime
      add_column :profiles, :company, :string
      add_column :profiles, :zip, :string
      add_column :profiles, :mobile_phone, :string
      add_column :profiles, :home_phone, :string
      add_column :profiles, :alumni_of, :string
      add_column :profiles, :relationship_status, :string
    end

    def self.down
      add_column :profiles, :occupation
      add_column :profiles, :gender
      add_column :profiles, :birthday
      add_column :profiles, :company
      add_column :profiles, :zip
      add_column :profiles, :mobile_phone
      add_column :profiles, :home_phone
      add_column :profiles, :alumni_of
      add_column :profiles, :relationship_status
    end
  end


Next create a new views/profiles/edit.html.erb file.  The built in file is very basic and makes it easy to add additional fields.  The 'profile_form' method will
create form elements for the built in fields.  Add extra fields after that.

  <div id="edit_content" class="span-24 colborder column">
    <%= output_errors(t('muck.profiles.problem_editing_profile'), {:class => 'help-box'}, @profile) %>
    <% profile_form(@profile) do |f| -%>
      <%# can add form fields as desired here -%>
    <% end -%>
  </div>

Last create view/profiles/show.html.erb.  There is a built in show page however it is assumed that most applications will implement a custom show page to hightlight
the focus of the system.

  <div class="span-24 colborder column">
    <%= icon @user, :thumb %>
    <p><%= @user.full_name %></p>
    <p><%= link_to t('muck.profiles.edit_profile'), edit_user_profile_path(@user) if @profile.can_edit?(current_user) %></p>
    <!-- Add more fields and customize the profile. -->
  </div>

It's important to sanitize user input. If you add fields to the profile then be sure to prevent cross site scripting.  Override the 'sanitize_attributes' method 
in your model and add your new fields.  Note that you can also override 'sanitize_level' to determine how sanitization occurs.

  # Sanitize content before saving.  This prevents XSS attacks and other malicious html.
  def sanitize_attributes
    if self.sanitize_level
      self.about = Sanitize.clean(self.about, self.sanitize_level)
      self.location = Sanitize.clean(self.location, self.sanitize_level)
      # add your fields
    end
  end

  # Override this method to control sanitization levels.
  # Currently a user who is an admin will not have their content sanitized.  A user
  # in any role 'editor', 'manager', or 'contributor' will be given the 'RELAXED' settings
  # while all other users will get 'BASIC'.
  #
  # Options are from sanitze:
  # nil - no sanitize
  # Sanitize::Config::RELAXED
  # Sanitize::Config::BASIC
  # Sanitize::Config::RESTRICTED
  # for more details see: http://rgrove.github.com/sanitize/
  def sanitize_level
    return Sanitize::Config::BASIC if self.user.nil?
    return nil if self.user.admin?
    return Sanitize::Config::RELAXED if self.user.any_role?('editor', 'manager', 'contributor')
    Sanitize::Config::BASIC
  end
  
  
  
Copyright (c) 2009 Tatemae, released under the MIT license
